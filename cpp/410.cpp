class Solution {
    /*
    题目：
    给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m 个非空的连续子数组。
设计一个算法使得这 m 个子数组各自和的最大值最小。
    思路：
    用二分法猜测子数组容量，例如7 2 5 10 8 ，假如只有一个子数组则容量为32，如果有5个子数组则容量就是最大的那个10
    故从【10，32】之间用二分。
    此外还有一个事实：
    如果设置的数组各自和的最大值」很大，则必然导致分组数split很小
    如果设置的数组各自和的最大值」很小，则必然导致分组数split很大
    第一次  mid = (10+32)/2=21  我们刚开始假设只有一个子数组，那么spilt=1, 然后把数字一个一个塞进去
    先塞7 7<21 继续 2 7+2<21 继续 7+2+5<21 继续 7+2+5+10>21 就意味着一个数组放不下我们让spilt+1=2并更新子数组和为0重新开始
    然后把后面的塞完,我们把need和m对比一下
    如果比m大说明我们开的子数组太多，也就意味值我们数组容量太小
    所以我们就从[22,32]右侧区间中找
    */
public:
    int splitArray(vector<int>& nums, int k) {
        //遇到最大化最小值或最小化最大值，就是二分查找，类似的题目有1014,875,774
        long left=0,right=0;// long avoid overlfow
        for(auto &d:nums){
            if(left<d){
                left=d;
            }
            right+=d;
        }
        while(left<right){
            long mid=left+(right-left)/2;
            // 判断数组各自和的最大值为mid时
            int spilt=1;
            int curSum=0;
            for(auto&d:nums){
                if(curSum+d>mid){
                    // 尝试加上当前遍历的这个数，如果加上去超过了「子数组各自的和的最大值」，就不加这个数，另起一个子数组，由于子数组是连续的，故下一个可以重新开始
                    spilt++;
                    curSum=0;
                }
                curSum+=d;
            }
            if(spilt>k){
                // 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大
                left=mid+1;
            }else{
                right=mid;
            }
        }
        return left;
    }
};
