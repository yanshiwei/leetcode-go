class Solution {
    /*
    给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
    */
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()<1){
            return 0;
        }
        //dp[i][j] 中 i 表示第 i 天，j为 [0−4]五个状态，dp[i][j]表示第 i天状态 j所得最大现金
        //j=0无操作=1第一次买入，2第一次卖出，3第二次买入，4第二次卖出
        /*
        |buy|buy|sell|sell|sell|buy|buy|
        |---|---|----|----|----|---|---|
                |    |
                  当天
                 第一次 保持
                  卖出
        */
        vector<vector<int>>dp(prices.size(),vector<int>(5,0));
        // init
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        dp[0][2]=0;
        dp[0][3]=-prices[0];
        dp[0][4]=0;//第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少
        for(int i=1;i<prices.size();i++){
            // 第i天无操作,则之前也是没有操作
            dp[i][0]=dp[i-1][0];
            // 第i天第一次买入
            dp[i][1]=max(
                dp[i-1][1],//前一天买入，当天保持
                dp[i-1][0]-prices[i]//当天买入，前一天还是没有操作
            );
            // 第i天第一次卖出
            dp[i][2]=max(
                dp[i-1][2],//前一天卖出，当天保持
                dp[i-1][1]+prices[i]//当天第一次卖出，前一天还是第一次买入
            );
            // 第i天第二次买入
            dp[i][3]=max(
                dp[i-1][3],//前一天买入，当天保持
                dp[i-1][2]-prices[i]//当天买入，前一天还是第一次卖出
            );    
            // 第i天第二次卖出
            dp[i][4]=max(
                dp[i-1][4],//前一天卖出，当天保持
                dp[i-1][3]+prices[i]//当天第二次卖出，前一天还是第二次买入
            );                    
        }
        return dp[prices.size()-1][4];
    }
};
