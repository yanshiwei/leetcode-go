class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        // 贪心。每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。
        // 题目：
        /*假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。*/
        // 给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干
        // 1 sort
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int g_idx=0;
        int s_idx=0;
        while(g_idx<g.size()&&s_idx<s.size()){
            if(g[g_idx]<=s[s_idx]){
                // 如果小孩胃口值小于或者等于饼干尺寸，则转到下一个小孩，否则仍停留在这个小孩
                g_idx++;
            }
            // 无论饼干尺寸是否能满足当前小孩，都需要指向下一个饼干进行判断
            // 第一种情况，饼干满足当前小孩，则被分掉，轮到下一个饼干
            // 第二种情况，饼干尺寸无法满足当前小孩时
            // 证明后面胃口更大的小孩更加无法满足，这个饼干无法被任何小孩吃，pass该饼干
            s_idx++;
        }
        // 返回最多可满足的小孩数量
        return g_idx;
    }
};
