class Solution {
    /*
    给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。
    s 由数字、'+'、'-'、'('、')'、和 ' ' 组成
    '+' 不能用作一元运算(例如， "+1" 和 "+(2 + 3)" 无效)
    '-' 可以用作一元运算(即 "-1" 和 "-(2 + 3)" 是有效的)
    */
public:
    int calculate(string s) {
       // 只有加减法，可以把括号全都展开来写，例如 2 - （1 - 3）展开成 2 - 1 + 3
       stack<int>ops;
       ops.push(1);// 默认正
       int sign=1;
       // 当前数字符号：
       // 1.与字符串中当前位置的运算符有关；
       // 2.如果当前位置处于一系列括号之内，则也与这些括号前面的运算符有关：每当遇到一个以 - 号开头的括号，则意味着此后的符号都要被「翻转」。我们需要维护一个栈ops，其中栈顶元素记录了当前位置所处的每个括号所「共同形成」的符号。例如，对于字符串1+2+(3-(4+5))：
       // 2.1 扫描到 1+2 时，由于当前位置没有被任何括号所包含，则栈顶元素为初始值 +1+
       // 2.2 扫描到}1+2+(3 时，当前位置被一个括号所包含，该括号前面的符号为 + 号，因此栈顶元素依然 +1
       // 2.3 扫描到1+2+(3-(4 时，当前位置被两个括号所包含，分别对应着 +号和 -号，由于 +号和 -号合并的结果为 -号，因此栈顶元素变为 -1
       int res=0;
       int i=0;
       while(i<s.size()){
           if(s[i]==' '){
               i++;
               continue;
           }else if(s[i]=='+'){
               sign=ops.top();
               i++;
           }else if(s[i]=='-'){
               sign=-ops.top();
               i++;
           }else if(s[i]=='('){
               ops.push(sign);//
               i++;
           }else if(s[i]==')'){
               ops.pop();
               i++;
           }else{
               // 数字
               long sum=0;
               while(i<s.size()&&s[i]>='0'&&s[i]<='9'){
                   sum=sum*10+(s[i]-'0');
                   i++;
               }
               res+=sign*sum;
           }
       }
       return res;
    }
};
