func numOfSubarrays(arr []int) int {
    var res int
    /*
    暴力，超时
    for i:=0;i<len(arr);i++{
        var tmpSum int
        for j:=i;j<len(arr);j++{
            tmpSum+=arr[j]
            if tmpSum%2==1{
                res++
            }
        }
    }
    */
    /*
    前缀和
    这道题要求返回和为奇数的子数组数目。为了快速计算任意子数组的和，可以通过维护前缀和的方式。这道题只需要知道每个子数组的和的奇偶性，不需要知道子数组的和的具体值，因此不需要维护每一个前缀和，只需要维护奇数前缀和的数量与偶数前缀和的数量。
    分别使用odd 和 even 表示奇数前缀和的数量与偶数前缀和的数量。初始时，odd=0，even=1，因为空的前缀的和是 0，也是偶数前缀和。
    遍历数组arr 并计算前缀和。对于下标 i的位置的前缀和（即 arr[0]+arr[1]+…+arr[i]），根据奇偶性进行如下操作：
        1.当下标 i 的位置的前缀和是偶数时，如果下标 j 满足 j < i且下标 j 的位置的前缀和是奇数，则从下标j+1 到下标 i 的子数组的和是奇数，因此，以下标 i 结尾的子数组中，和为奇数的子数组的数量即为奇数前缀和的数量 odd；
        2.当下标 i 的位置的前缀和是奇数时，如果下标 j 满足 j < i 且下标j的位置的前缀和是偶数，则从下标 j+1 到下标 i的子数组的和是奇数，因此，以下标 i 结尾的子数组中，和为奇数的子数组的数量即为偶数前缀和的数量 even。

    上述下标 j 的最小可能取值为 −1，当j=−1 时表示下标 j的位置的前缀为空。

    在更新和为奇数的子数组数量之后，需要根据下标 i 的位置的前缀和的奇偶性更新 odd 或 even 的值。如果前缀和是奇数，则 odd 的值加 1；如果前缀和是偶数，则 even 的值加 1。
    举例说明：
    如果当前和为奇数的话：例如[1, 2, 3, 4, 5], 计算到第5个数时和为奇数，想要获取以5结尾的子数组奇数和，我们只要减去前缀和为偶数的即可，例如减去[1, 2, 3], 这样这个序列就剩下[4, 5]是奇数，也是新增的项，还可以减去[1, 2, 3, 4], 剩下[5], 也是新增的一项，本质为：奇数 - 偶数 = 奇数，意思就是说，有几个偶前缀和，就新增几项。相反的，如果当前和为偶数，只需要减去所有奇数的前缀和，即为新增的数目，本质为：偶数 - 奇数 = 奇数。最后把当前的和是奇数，令前缀和为奇数的++, 反之亦然
    */
    var sum int
    var odd int//奇数和数目
    var even=1//偶数和数目，因为空的前缀的和是0，也是偶数前缀和
    for i:=range arr{
        sum+=arr[i]
        if sum%2==0{
            //和为偶数时，和为奇数的子数组数目为奇数前缀和的数量odd
            res=(res+odd)%1000000007
            even++
        }else{
            //和为奇数时，和为奇数的子数组数目为偶数前缀和的数量even
            res=(res+even)%1000000007
            odd++
        }
    }
    return res
}
