func arrayPairSum(nums []int) int {
    /*
    排序然后取所有下标为偶数的项求和即可。其正确性的证明如下，为了方便理解，以下证明时的索引是从1开始计数的
    对园数组排序后得P=（p1,p2,p3,p4,...,p2n）。任务分成n对后，取每一对得最小值出来排序得到S=(s1,s2,...,sn)，
    针对每一个si其配对得另一半是bi（bi>=si）。
    肯定存在一种情况S0=(p1,p3,p5,...,p2n-1)，如果正面其他任意情况S=(s1,s2,...,sn)中任意一点si<=p2i-1，按照题目
    最小值最大化要求就知道S0就是最优解。
    证明：至少有2(n-i)+1个元素是大于或等于si的，即si+1,si+2,...,sn这n-i个与bi,bi+1,bi+2,bn这n-i+1个
    故si在P中的位置最大肯定是2n-[2(n-i)+1]=2i-1也就是si<=p2i-1。
    得证！故S0=(p1,p3,p5,...,p2n-1)就是最优解
    */
    sort.Ints(nums)
    var res int
    //选择索引为0、2、4、6、8...
    for i:=range nums {
        if i%2==0 {
            res+=nums[i]
        }
    }
    return res
}
